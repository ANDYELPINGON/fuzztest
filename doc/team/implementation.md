# FuzzTest Implementation Notes

IMPORTANT: this document is an internal team document for extending FuzzTest. Do
not extend your own types for FuzzTest without first consulting the FuzzTest
team. Instead, use the existing domains or combinators of existing domains as
noted within the [Domains Reference](../domains-reference.md).

FuzzTest is an extensible framework. This guide documents how to extend FuzzTest
to fuzz types appropriately and intelligently using custom domains.

## Domains

This is a skeleton for a Domain implementation. Note that a Domain object is not
designed to retain state, but only provide mutation and generation services for
values of a given type.

Conceptually, a Domain represents a space of possible values, and a method for
traversing that space. A concept of 'nearness' is useful if possible; for
example, a Domain that mutates the string `cheese` to `chease` is useful in a
way that one which is as likely to mutate it to `xyzzy` is not.

```c++
template <typename UserValueT>
class MyDomain {
 public:
  using user_value_t = UserValueT;

  MyDomain(/* params */) {
    /* set up space of possible values here */
  }

  T Init(absl::BitGenRef prng) {}

  void Mutate(T& val, absl::BitGenRef prng, bool only_shrink) {}

 private:
  /* params stored here */
}
```

### Init

```c++
T Init(absl::BitGenRef prng);
```

The `Init` method returns an arbitrary value in the domain. This may be, for
example, an empty container for a container type, or a random element for an
`ElementOf` domain. Note that this is separate from a *constructor*; a
constructor sets up a Domain, and `Init` produces an initial value from it.

### Mutate

```c++
void Mutate(T& val, absl::BitGenRef prng, bool only_shrink);
```

The `Mutate` method makes a small change on an existing value. The `only_shrink`
parameter is used for case reduction; the precise semantics of what it means to
grow or shrink a value of a given type are type-specific.

There is no guarantee that `val` is within the Domain's possibility space. For
example, a Domain representing positive integers could be given the number -1.
In cases where this is possible, it is recommended that `Mutate` simply call
`Init` on nonconforming inputs.

## Custom `corpus_value_t`

Domains have a corpus value type (`corpus_value_t`) which is by default the same
as the `user_value_t`. The corpus value represents the internal representation
that the domains works on (e.g., the value that gets mutated), while the
`user_value_t` value represents the domain's output. For example, consider a
domain which represents strings generated by a regular expression. It's much
easier to mutate an explicit DFA path than to convert a string back and forth,
so we use `std::string` as the `user_value_t` and a representation of the path
as the `corpus_value_t`.

```c++
class RegexDomain {
 public:
  using user_value_t = std::string;
  using corpus_value_t = DFAPath;

  RegexDomain(std::string regex) : dfa_(DFA::Parse(regex)) {}

  corpus_value_t Init(absl::BitGenRef prng) {
    return dfa_.Generate(prng);
  }

  void Mutate(corpus_value_t& val, absl::BitGenRef prng, bool only_shrink) {
    dfa_.Mutate(prng, val);
  }

  user_value_t CorpusToUserValue(const corpus_value_t& value) const {
    return dfa_.ToString(value);
  }

 private:
  DFA dfa_;
}
```
